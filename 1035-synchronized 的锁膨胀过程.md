# synchronized 的锁膨胀过程

synchronized 是 Java 面试的常客，我们需要掌握它的基本使用，比如同步代码块、同步普通方法、同步静态方法，以及他们的区别，当然这是最初级的。高级点的就是需要掌握 synchronized 的实现原理，比如对象头、synchronized 的锁优化、锁的膨胀过程，这篇文章就是介绍 synchronized 的锁膨胀过程。该过程其实很多小伙伴都不知道，18年面试的时候问了不下于 20 个人，没有一个回答比较好的，甚至有将近一半的人都不知道有这个。

synchronized 同步锁一共具有四种状态：无锁、偏向锁、轻量级锁、重量级锁，他们会随着竞争情况逐渐升级，此过程为不可逆。所以 synchronized 锁膨胀过程其实就是**无锁 → 偏向锁 → 轻量级锁 → 重量级锁**的一个过程。要理解这个过程就一定要对偏向锁和轻量级锁有一定的认识，如果小伙伴不熟悉则可以移步[【死磕Java并发】—–深入分析synchronized的实现原理](http://cmsblogs.com/?p=2071)，这篇文章有较为详细的说明。下面就偏向锁和轻量级锁做一个简要的总结。

**偏向锁**

引入偏向锁的主要目的是：为了在无多线程竞争的情况下尽量减少不必须要的轻量级锁执行路径。其实在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，所以引入偏向锁就可以减少很多不必要的性能开销和上下文切换。

**轻量级锁**

引入轻量级锁的主要目的是：在多线程竞争不激烈的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。需要注意的是轻量级锁并不是取代重量级锁，而是在大多数情况下同步块并不会出现严重的竞争情况，所以引入轻量级锁可以减少重量级锁对线程的阻塞带来的开销。

所以偏向锁是认为环境中不存在竞争情况，而轻量级锁则是认为环境中不存在竞争或者竞争不激烈，轻量级锁所以一般都只会有少数几个线程竞争锁对象，其他线程只需要稍微等待（自旋）下就可以获取锁，但是自旋次数有限制，如果超过该次数，则会升级为重量级锁。

下面介绍锁膨胀过程，直接看图：

![202105091636188501.png](https://www.cmsblogs.com/images/group/sike-java/sike-java-bingfa/202105091636188501.png)

(图片来自：https://my.oschina.net/hosee/blog/2878328)

synchronized 用的锁是存储在 Java 对象头里的，下图是锁状态变化的情况，在分析 synchronized 锁升级需要对照这图：

![202105091636215742.png](https://www.cmsblogs.com/images/group/sike-java/sike-java-bingfa/202105091636215742.png)

- 一个锁对象刚刚开始创建的时候，没有任何线程来访问它，它是可偏向的，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问他的时候，它会偏向这个线程。此时线程状态为无锁状态，锁标志位为 01，此时 Mark Word 如下图：

![202105091636219703.png](https://www.cmsblogs.com/images/group/sike-java/sike-java-bingfa/202105091636219703.png)

- 当一个线程（线程 A）来获取锁的时，会首先检查所标志位，此时锁标志位为 01，然后检查是否为偏向锁，此时不为偏向锁，所以当前线程会修改对象头状态为偏向锁，同时将对象头中的 ThreadID 改成自己的 Thread ID，此时 Mark Word 如下图

![202105091636221104.png](https://www.cmsblogs.com/images/group/sike-java/sike-java-bingfa/202105091636221104.png)

- 如果再有一个线程（线程 B）过来，此时锁状态为偏向锁，该线程会检查 Mark Word 中记录的线程 ID 是否为自己的线程 ID，如果是，则获取偏向锁，执行同步代码块。如果不是，则利用 CAS 尝试替换 Mark Word 中的 Thread ID，成功，表示该线程（线程 B）获取偏向锁，执行同步代码块，此时 Mark Word 如下图：

![202105091636222535.png](https://www.cmsblogs.com/images/group/sike-java/sike-java-bingfa/202105091636222535.png)

- 如果失败，则表明当前环境存在锁竞争情况，则执行偏向锁的撤销工作（**这里有一点需要注意的是：偏向锁的释放并不是主动，而是被动的，什么意思呢？就是说持有偏向锁的线程执行完同步代码后不会主动释放偏向锁，而是等待其他线程来竞争才会释放锁**）。撤销偏向锁的操作需要等到全局安全点才会执行，然后暂停持有偏向锁的线程，同时检查该线程的状态，如果该线程不处于活动状态或者已经退出同步代码块，则设置为无锁状态（线程 ID 为空，是否为偏向锁为 0 ，锁标志位为01）重新偏向，同时恢复该线程。若该线程活着，则会遍历该线程栈帧中的锁记录，检查锁记录的使用情况，如果仍然需要持有偏向锁，则撤销偏向锁，升级为轻量级锁。
- 在升级为轻量级锁之前，持有偏向锁的线程（线程 A）是暂停的，JVM 首先会在原持有偏向锁的线程（线程 A）的栈中创建一个名为锁记录的空间（Lock Record），用于存放锁对象目前的 Mark Word 的拷贝，然后拷贝对象头中的 Mark Word 到原持有偏向锁的线程（线程 A）的锁记录中（官方称之为 Displaced Mark Word ），这时线程 A 获取轻量级锁，此时 Mark Word 的锁标志位为 00，指向锁记录的指针指向线程 A 的锁记录地址，如下图：

![202105091636223756.png](https://www.cmsblogs.com/images/group/sike-java/sike-java-bingfa/202105091636223756.png)

- 当原持有偏向锁的线程（线程 A）获取轻量级锁后，JVM 唤醒线程 A，线程 A 执行同步代码块，执行完成后，开始轻量级锁的释放过程。
- 对于其他线程而言，也会在栈帧中建立锁记录，存储锁对象目前的 Mark Word 的拷贝。JVM 利用 CAS 操作尝试将锁对象的 Mark Word 更正指向当前线程的 Lock Record，如果成功，表明竞争到锁，则执行同步代码块，如果失败，那么线程尝试使用自旋的方式来等待持有轻量级锁的线程释放锁。当然，它不会一直自旋下去，因为自旋的过程也会消耗 CPU，而是自旋一定的次数，如果自旋了一定次数后还是失败，则升级为重量级锁，阻塞所有未获取锁的线程，等待释放锁后唤醒。
- 轻量级锁的释放，会使用 CAS 操作将 Displaced Mark Word 替换会对象头中，成功，则表示没有发生竞争，直接释放。如果失败，表明锁对象存在竞争关系，这时会轻量级锁会升级为重量级锁，然后释放锁，唤醒被挂起的线程，开始新一轮锁竞争，注意这个时候的锁是重量级锁。